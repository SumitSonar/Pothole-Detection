# -*- coding: utf-8 -*-
"""project.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1eD7S_oF9D7G35lVOpV_71lFyaO_AxC_1
"""

# Step 1: Install necessary libraries for accessing Google Drive
!pip install -U -q PyDrive

# Step 2: Import necessary libraries for PyTorch and accessing Google Drive
import torch
import torch.nn as nn
import torch.optim as optim
from torch.utils.data import Dataset, DataLoader
import torchvision.transforms as transforms
import torchvision.models as models
import os
from PIL import Image
import cv2
import numpy as np

# Step 4: Mount Google Drive
from google.colab import drive as gdrive
gdrive.mount('/content/drive')

# Step 5: Copy your dataset folder from Google Drive to Colab's local environment
# Replace '/content/drive/MyDrive/path_to_your_dataset_folder' with the actual path of your dataset in Drive
!cp -r /content/drive/MyDrive/dataset /content/dataset

# Step 6: Custom Dataset for Pothole Detection
class PotholeDataset(Dataset):
    def __init__(self, root_dir, transform=None):
        self.root_dir = root_dir
        self.transform = transform
        self.image_paths = []
        self.labels = []

        # Load image paths and labels
        for label, subdir in enumerate(['no_potholes', 'potholes']):  # Folder structure expected to be 'no_potholes' and 'potholes'
            subdir_path = os.path.join(root_dir, subdir)
            for img_name in os.listdir(subdir_path):
                self.image_paths.append(os.path.join(subdir_path, img_name))
                self.labels.append(label)  # 0 for no_potholes, 1 for potholes

    def __len__(self):
        return len(self.image_paths)

    def __getitem__(self, idx):
        img_path = self.image_paths[idx]
        image = Image.open(img_path).convert("RGB")
        label = self.labels[idx]

        if self.transform:
            image = self.transform(image)

        return image, label

# Step 7: Data Preprocessing: Image Augmentation and Normalization
transform = transforms.Compose([
    transforms.Resize((224, 224)),  # Resize images to 224x224 for ResNet
    transforms.RandomHorizontalFlip(),
    transforms.RandomRotation(10),
    transforms.ToTensor(),
    transforms.Normalize(mean=[0.485, 0.456, 0.406], std=[0.229, 0.224, 0.225])
])

# Step 8: Load dataset from the local folder (Colab environment)
root_dir = '/content/drive/MyDrive/dataset'  # Path where the dataset is stored
batch_size = 32
train_dataset = PotholeDataset(root_dir=root_dir, transform=transform)
train_loader = DataLoader(train_dataset, batch_size=batch_size, shuffle=True)

# Step 9: Load Pre-trained ResNet18 Model and modify the final layer
model = models.resnet18(pretrained=True)
model.fc = nn.Linear(model.fc.in_features, 2)  # Binary classification (potholes vs no_potholes)

# Step 10: Define Loss Function and Optimizer
criterion = nn.CrossEntropyLoss()
optimizer = optim.Adam(model.parameters(), lr=0.0001)

# Step 11: Training Loop
num_epochs = 10
device = torch.device('cuda' if torch.cuda.is_available() else 'cpu')
model = model.to(device)

for epoch in range(num_epochs):
    model.train()
    running_loss = 0.0
    correct = 0
    total = 0

    for images, labels in train_loader:
        images, labels = images.to(device), labels.to(device)

        optimizer.zero_grad()  # Clear gradients
        outputs = model(images)  # Forward pass
        loss = criterion(outputs, labels)  # Loss calculation

        loss.backward()  # Backward pass
        optimizer.step()  # Update weights

        # Track accuracy
        _, predicted = torch.max(outputs, 1)
        total += labels.size(0)
        correct += (predicted == labels).sum().item()

        running_loss += loss.item()

    print(f'Epoch [{epoch+1}/{num_epochs}], Loss: {running_loss/len(train_loader):.4f}, Accuracy: {100 * correct/total:.2f}%')

print("Training completed!")

# Save the trained model
model_save_path = "/content/drive/MyDrive/pothole_detection_model.pth"  # Path to save model in Google Drive
torch.save(model.state_dict(), model_save_path)
print(f"Model saved to {model_save_path}")

# Load the saved model for inference
model_load_path = "/content/drive/MyDrive/pothole_detection_model.pth"  # Path where the model was saved
model = models.resnet18(pretrained=False)  # Initialize model architecture
model.fc = nn.Linear(model.fc.in_features, 2)  # Binary classification
model.load_state_dict(torch.load(model_load_path))  # Load the saved parameters
model = model.to(device)  # Move model to device (GPU/CPU)
model.eval()  # Set model to evaluation mode
print("Model loaded and ready for inference!")

# Step 12: Function to Predict Potholes in a Single Image
def detect_pothole_in_image(image_path, model, transform, device):
    # Load and preprocess the image
    image = Image.open(image_path).convert("RGB")
    input_image = transform(image).unsqueeze(0).to(device)

    # Perform inference
    model.eval()  # Set the model to evaluation mode
    with torch.no_grad():
        output = model(input_image)
        _, predicted = torch.max(output, 1)

    # Print prediction result
    if predicted.item() == 1:
        print("Pothole detected in the image!")
    else:
        print("No pothole detected in the image.")

# Example usage
image_path = "/content/i3.jpeg"  # Path to your image
detect_pothole_in_image(image_path, model, transform, device)

import torch
import cv2
import matplotlib.pyplot as plt
from PIL import Image
import numpy as np

# Step 12: Function to Predict Potholes in a Single Image and Display with Circle
def detect_pothole_in_image(image_path, model, transform, device):
    # Load and preprocess the image
    image = Image.open(image_path).convert("RGB")
    input_image = transform(image).unsqueeze(0).to(device)

    # Perform inference
    model.eval()  # Set the model to evaluation mode
    with torch.no_grad():
        output = model(input_image)
        _, predicted = torch.max(output, 1)

    # Convert PIL image to OpenCV format for drawing the circle
    image_cv2 = cv2.cvtColor(np.array(image), cv2.COLOR_RGB2BGR)

    # Draw a circle if a pothole is detected
    if predicted.item() == 1:
        print("Pothole detected in the image!")

        # Assuming you can approximate the position of the pothole in the image,
        # let's find contours of the detected pothole. This is a simulated example.
        # Convert to grayscale for better contour detection.
        gray_image = cv2.cvtColor(image_cv2, cv2.COLOR_BGR2GRAY)
        _, thresh = cv2.threshold(gray_image, 128, 255, cv2.THRESH_BINARY_INV)

        # Find contours
        contours, _ = cv2.findContours(thresh, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)

        # If contours are found, draw the bounding box around the largest contour
        if contours:
            # Find the largest contour
            largest_contour = max(contours, key=cv2.contourArea)
            (x, y, w, h) = cv2.boundingRect(largest_contour)

            # Draw a rectangle around the pothole
            cv2.rectangle(image_cv2, (x, y), (x + w, y + h), (0, 255, 0), 2)  # Green rectangle

            # Optionally draw a circle at the center of the detected bounding box
            center_x = x + w // 2
            center_y = y + h // 2
            radius = min(w, h) // 4
            cv2.circle(image_cv2, (center_x, center_y), radius, (0, 0, 255), 2)  # Red circle
            cv2.putText(image_cv2, "Pothole", (center_x - 70, center_y - radius - 10),
                        cv2.FONT_HERSHEY_SIMPLEX, 1, (0, 0, 255), 2)

    else:
        print("No pothole detected in the image.")

    # Convert the OpenCV image (BGR) back to RGB format for displaying in matplotlib
    image_rgb = cv2.cvtColor(image_cv2, cv2.COLOR_BGR2RGB)

    # Display the image with/without detection in Colab using matplotlib
    plt.imshow(image_rgb)
    plt.axis('off')  # Hide axis for better visualization
    plt.show()

# Example usage
image_path = "/content/69.jpg"  # Path to your image
detect_pothole_in_image(image_path, model, transform, device)

